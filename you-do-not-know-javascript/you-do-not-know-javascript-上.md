## 阅你不知道的JavaScript(上卷).pdf笔记

### 1作用域

#### 1.1编译原理

编译时间: 代码执行前的少量时间(几微秒)

    * 分词/词法分析: 解析文本字符为代码块, 如:["var", "a", "=", "2"]
    * 解析/语法分析: 将代码单元转换为树结构
    * 代码生成: 生成引擎可执行代码

还包括一些优化步骤等.

#### 1.2作用域

    * 分为引擎,编译器,作用域三部分
    * 编译器编译完成后,引擎执行操作,变量存在于作用域中;
    * 分清LHS(查找存储地址)和RHS(查找存储值);

请分析例子:
```
function foo(a) {
    var b = a;
    return a + b;
}
var c = foo( 2 );
```

LHS(3), RHS(4)

#### 1.3作用域嵌套
引擎会延着作用域链查找变量,直到找到或查到全局变量为止,若未找到,LHS非严格模式会创建全局变量给引擎,否则报错ReferenceError

### 2词法作用域

在编译的时候生成的作用域,由声明的代码块位置决定.而有两种方式可以修改词法作用域:
    * eval: 将字符串改为代码,类似的有setTimeout, setInterval, new Function等
    * with: 创建一个新的作用域

以上两种方式不推荐使用

### 3函数作用域,块级作用域

#### 3.1函数作用域
    * 内部作用域可以访问外部的,外部的无法访问内部作用域
    * 最小暴露原则
    * 立执行函数
        1 匿名函数坏处1,调试困难 2,引用自身只能用arguments.callee 3,可读性差

        2 传global,避免修改undefined等

#### 3.2块级作用域
在ES5.1中其实并没有块级概念, 在{}的声明也会污染作用域, 生成块作用域的方法如下:
    * with
    * try{}catch(eee){}
    * let--此处分隐式和显式
    * const

### 4声明提升
    * 变量声明和函数声明,会在预编译时声明在作用域内
    * 函数优先
    * 避免块作用域中声明函数

分析下例:
```
foo(); // 3

function foo() {
    console.log( 1 );
}

var foo = function() {
    console.log( 2 );
};

function foo() {
    console.log( 3 );
}
```
